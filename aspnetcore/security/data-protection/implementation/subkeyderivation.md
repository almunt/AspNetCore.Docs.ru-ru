---
title: Наследование подраздела и шифрование с проверкой подлинности в ASP.NET Core
author: rick-anderson
description: Сведения о реализации ASP.NET Core наследования подраздела защиты данных и шифрования с проверкой подлинности.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: f373c37a5ea4dab91463d011d3ecd6799ae6d014
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85408036"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="2bcbd-103">Наследование подраздела и шифрование с проверкой подлинности в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="2bcbd-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="2bcbd-104">Большинство ключей в кольце ключа будет содержать некоторую форму энтропии и будет содержать алгоритмы, указывающие "шифрование режима CBC + проверка HMAC" и "шифрование GCM + проверка".</span><span class="sxs-lookup"><span data-stu-id="2bcbd-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="2bcbd-105">В этих случаях в качестве главного материала для ключа (или км) мы будем обращаться к внедренной энтропии, а для получения ключей, которые будут использоваться для фактических криптографических операций, используется функция формирования ключа.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="2bcbd-106">Ключи являются абстрактными, и пользовательская реализация может работать не так, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="2bcbd-107">Если ключ предоставляет собственную реализацию `IAuthenticatedEncryptor` вместо использования одной из встроенных фабрик, механизм, описанный в этом разделе, больше не применяется.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="2bcbd-108">Дополнительные данные с проверкой подлинности и наследование подраздела</span><span class="sxs-lookup"><span data-stu-id="2bcbd-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="2bcbd-109">`IAuthenticatedEncryptor`Интерфейс выступает в качестве базового интерфейса для всех операций шифрования, прошедших проверку подлинности.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="2bcbd-110">Его `Encrypt` метод принимает два буфера: обычный текст и аддитионалаусентикатеддата (AAD).</span><span class="sxs-lookup"><span data-stu-id="2bcbd-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="2bcbd-111">Поток содержимого в виде обычного текста не изменил вызов `IDataProtector.Protect` , а AAD создается системой и состоит из трех компонентов:</span><span class="sxs-lookup"><span data-stu-id="2bcbd-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="2bcbd-112">32-разрядный заголовок Magic F0 C9 F0, определяющий эту версию системы защиты данных.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="2bcbd-113">Идентификатор 128-разрядного ключа.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="2bcbd-114">Строка переменной длины, сформированная из цепочки назначений, создавшей объект `IDataProtector` , выполняющий эту операцию.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="2bcbd-115">Поскольку AAD является уникальным для кортежа всех трех компонентов, мы можем использовать его для получения новых ключей с км вместо того, чтобы использовать каждый из этих криптографических операций.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="2bcbd-116">При каждом вызове `IAuthenticatedEncryptor.Encrypt` происходит следующий процесс формирования ключа:</span><span class="sxs-lookup"><span data-stu-id="2bcbd-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="2bcbd-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (K_M, AAD, Контекссеадер | | Кэймодифиер)</span><span class="sxs-lookup"><span data-stu-id="2bcbd-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="2bcbd-118">Здесь мы вызываем директиву NIST SP800-108 ПОДПРОГРАММ в режиме счетчика (см. директиву [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) со следующими параметрами:</span><span class="sxs-lookup"><span data-stu-id="2bcbd-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="2bcbd-119">Ключ наследования ключа (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="2bcbd-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="2bcbd-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="2bcbd-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="2bcbd-121">Метка = Аддитионалаусентикатеддата</span><span class="sxs-lookup"><span data-stu-id="2bcbd-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="2bcbd-122">context = Контекссеадер | | кэймодифиер</span><span class="sxs-lookup"><span data-stu-id="2bcbd-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="2bcbd-123">Заголовок контекста имеет переменную длину и, по сути, служит отпечаткой алгоритмов, для которых мы получаем K_E и K_H.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="2bcbd-124">Модификатор ключа — это 128-разрядная строка, создаваемая случайным образом для каждого вызова `Encrypt` и служащая для обеспечения перегруженной вероятности, что для данной конкретной операции шифрования проверки подлинности регистр и KH являются уникальными, даже если все остальные входные данные в подпрограмм являются постоянными.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="2bcbd-125">Для операций шифрования в режиме CBC и проверки HMAC | K_E | Длина ключа шифра симметричного блока и | K_H | Размер дайджеста подпрограммы HMAC.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="2bcbd-126">Для операций шифрования GCM и проверки: | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="2bcbd-127">Шифрование в режиме CBC и проверка HMAC</span><span class="sxs-lookup"><span data-stu-id="2bcbd-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="2bcbd-128">После создания K_E с помощью приведенного выше механизма создается случайный вектор инициализации и запускается алгоритм симметричного блочного шифра, шифрования паролей обычный текст.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="2bcbd-129">Затем вектор инициализации и зашифрованный текст выполняются с помощью процедуры HMAC, инициализированной с помощью ключа K_H для создания компьютера MAC.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="2bcbd-130">Этот процесс и возвращаемое значение представлены графически ниже.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-130">This process and the return value is represented graphically below.</span></span>

![Процесс и возврат в режиме CBC](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="2bcbd-132">*выходные данные: = Кэймодифиер | | IV | | E_cbc (K_E, IV, данные) | | HMAC (K_H, IV | | E_cbc (K_E, IV, Data))*</span><span class="sxs-lookup"><span data-stu-id="2bcbd-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="2bcbd-133">`IDataProtector.Protect`Реализация будет [добавлять в начале вывода заголовок Magic и идентификатор ключа](xref:security/data-protection/implementation/authenticated-encryption-details) , прежде чем возвращать его вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="2bcbd-134">Так как заголовок Magic и идентификатор ключа неявно являются частью [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), и так как модификатор ключа помещается в качестве входных данных для подпрограмм, это означает, что каждый байт окончательно возвращенных полезных данных проходит проверку подлинности Mac.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="2bcbd-135">Шифрование и проверка галоис/режим счетчика</span><span class="sxs-lookup"><span data-stu-id="2bcbd-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="2bcbd-136">После создания K_E с помощью приведенного выше механизма мы создаем случайный 96-разрядный nonce и запустили алгоритм симметричного блочного шифра для шифрования паролейия открытого текста и создания тега 128-разрядной проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Процесс и возврат в режиме GCM](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="2bcbd-138">*выходные данные: = Кэймодифиер | | nonce | | E_gcm (K_E, nonce, данные) | | аустаг*</span><span class="sxs-lookup"><span data-stu-id="2bcbd-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="2bcbd-139">Несмотря на то, что GCM изначально поддерживает концепцию AAD, мы все еще передаем AAD только первоначальному ПОДПРОГРАММу, пропуская пустую строку в GCM для своего параметра AAD.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="2bcbd-140">Причина этого состоит в двух разделах.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-140">The reason for this is two-fold.</span></span> <span data-ttu-id="2bcbd-141">Во первых, [для обеспечения гибкости](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) мы никогда не будем использовать K_M напрямую в качестве ключа шифрования.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="2bcbd-142">Кроме того, GCM накладывает очень строгое требование уникальности на входные данные.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="2bcbd-143">Вероятность того, что подпрограммы шифрования GCM когда-либо вызваны для двух или более отдельных наборов входных данных с одинаковой парой (Key, nonce), не должна превышать 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="2bcbd-144">Если исправить K_E мы не можем выполнить более 2 операций шифрования в ^ 32 до выполнения афаул из 2 ^-32 ограничения.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="2bcbd-145">Это может показаться очень большим количеством операций, но веб-сервер с большим трафиком может пройти через 4 000 000 000 запросов в течение всего дня, а не в течение обычного времени существования этих ключей.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="2bcbd-146">Чтобы обеспечить соответствие требованиям 2 ^-32, мы продолжаем использовать модификатор с 128-битным ключом и 96-bit nonce, который радикально расширяет количество используемых операций для всех заданных K_M.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="2bcbd-147">Для простоты проектирования мы используем путь кода ПОДПРОГРАММ между операциями CBC и GCM, а так как AAD уже рассматривается в ПОДПРОГРАММ, нет необходимости пересылать его в подпрограмму GCM.</span><span class="sxs-lookup"><span data-stu-id="2bcbd-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
