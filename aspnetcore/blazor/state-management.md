---
title: Управление состоянием ASP.NET Core Blazor
author: guardrex
description: Узнайте, как сохранить состояние в приложениях Blazor Server.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 05/19/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: blazor/state-management
ms.openlocfilehash: 59adcce972b503a6aa6e596bc9bff63225961f84
ms.sourcegitcommit: 066d66ea150f8aab63f9e0e0668b06c9426296fd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85243204"
---
# <a name="aspnet-core-blazor-state-management"></a>Управление состоянием ASP.NET Core Blazor

Автор: [Стив Сандерсон](https://github.com/SteveSandersonMS) (Steve Sanderson)

Blazor Server — это платформа приложений с отслеживанием состояния. В большинстве случаев приложение поддерживает постоянное подключение к серверу. Состояние пользователя хранится в памяти сервера в *канале*. 

Ниже приведены примеры состояния, удерживаемого для канала пользователя.

* Отображаемый пользовательский интерфейс. Иерархия экземпляров компонента и их последних выходных данных отрисовки.
* Значения всех полей и свойств в экземплярах компонента.
* Данные, хранящиеся во [внедрениях зависимостей (DI)](xref:fundamentals/dependency-injection) экземпляров службы, областью действия которых является канал.

> [!NOTE]
> В этой статье рассматривается сохранение состояния в приложениях Blazor Server. В приложениях Blazor WebAssembly можно использовать [сохранение состояния на стороне клиента в браузере](#client-side-in-the-browser), но для этого требуются пользовательские решения или сторонние пакеты, что выходит за рамки этой статьи.

## <a name="blazor-circuits"></a>Каналы Blazor

Если пользователь испытывает временный сбой сетевого подключения, Blazor пытается повторно подключить пользователя к исходному каналу, чтобы он мог продолжить использовать приложение. Однако повторное подключение пользователя к исходному каналу в памяти сервера не всегда возможно.

* Сервер не может постоянно хранить отключенную цепь. Сервер должен освободить отключенную цепь после истечения времени ожидания или при нехватке памяти на сервере.
* В многосерверных средах развертывания с балансировкой нагрузки любые запросы на обработку сервера могут стать недоступными в любой конкретный момент времени. Отдельные серверы могут выйти из строя или быть автоматически удалены, если они больше не требуются для обработки общего объема запросов. Когда пользователь попытается подключиться повторно, исходный сервер может стать недоступным.
* Пользователь может закрыть и снова открыть браузер или перезагрузить страницу, что приведет к удалению всех состояний, хранящихся в памяти браузера. Например, теряются значения, заданные через вызовы взаимодействия JavaScript.

Если пользователь не может повторно подключиться к исходному каналу, он получает новый канал с пустым состоянием. Это эквивалентно закрытию и повторному открытию классического приложения.

## <a name="preserve-state-across-circuits"></a>Сохранение состояния при смене каналов

В некоторых сценариях желательно сохранять состояние при переходе от одного канала к другому. Приложение может хранить важные данные для пользователя в следующих случаях:

* веб-сервер становится недоступным;
* браузер пользователя вынужден начать новый канал с новым веб-сервером.

Как правило, поддержание состояния между каналами применяется к сценариям, где пользователи активно могут создавать данные, а не просто считывать уже существующие данные.

Чтобы сохранить состояние за пределами одного канала, *недостаточно просто сохранить данные в памяти сервера*. Приложение должно сохранять данные в другое место хранения. Сохраняемость состояния не обеспечивается автоматически. При разработке приложения необходимо выполнить определенные действия для реализации сохраняемости данных с отслеживанием состояния.

Сохраняемость данных, как правило, требуется только для состояния высокой ценности, на создание которого пользователь затратил значительные усилия. В следующих примерах сохранение состояния экономит время или средства в коммерческих действиях.

* Многошаговая веб-форма. Пользователю потребуется много времени для повторного ввода данных для нескольких завершенных шагов многоэтапного процесса, если их данные о состоянии будут утеряны. В этом сценарии пользователь потеряет состояние, если он выйдет из многошаговой формы и снова вернется в нее.
* Корзина для покупок. Любой коммерчески важный компонент приложения, который представляет потенциальную прибыль. Пользователь, который теряет свое состояние, и, следовательно, свою корзину с покупками, может приобрести меньше товаров или услуг, когда вернется на сайт позже.

Обычно нет необходимости сохранять легко воссозданное состояние, например имя пользователя, введенное в диалоговое окно входа, которое еще не было отправлено.

> [!IMPORTANT]
> Приложение может сохранять только *состояния приложения*. Пользовательские интерфейсы не могут быть сохранены, например экземпляры компонентов и их деревья отрисовки. Компоненты и деревья отрисовки обычно не являются сериализуемыми. Чтобы сохранить нечто похожее на состояние пользовательского интерфейса, например развернутые узлы элементов TreeView, приложение должно иметь пользовательский код для моделирования поведения как сериализуемого состояния приложения.

## <a name="where-to-persist-state"></a>Место сохранения состояния

Существует три общих расположения для сохранения состояния в приложении Blazor Server. Каждый подход лучше всего подходит для определенных сценариев и имеет свои подводные камни:

* [На стороне сервера в базе данных](#server-side-in-a-database)
* [URL-адрес](#url)
* [На стороне клиента в браузере](#client-side-in-the-browser)

### <a name="server-side-in-a-database"></a>На стороне сервера в базе данных

Для постоянного сохранения данных или для данных, которые должны охватывать несколько пользователей или устройств, независимая база данных на стороне сервера почти наверняка является лучшим выбором. Доступные параметры:

* Реляционная база данных SQL
* Хранилище ключ-значение
* Хранилище больших двоичных объектов
* Хранилище таблиц

После сохранения данных в базе данных пользователь может запустить новый канал в любое время. Данные пользователя сохранены и доступны в любом новом канале.

Дополнительные сведения о вариантах хранения данных Azure см. в [документации по службе хранилища Azure](/azure/storage/) и [документации по базам данных Azure](https://azure.microsoft.com/product-categories/databases/).

### <a name="url"></a>URL-адрес

Для временных данных, представляющих состояние навигации, моделируют данные как часть URL-адреса. Ниже приведены примеры состояний, которые моделируются в URL-адресе.

* Идентификатор просматриваемой сущности.
* Номер текущей страницы в постраничной сетке.

Содержимое адресной строки браузера будет сохраняться в следующих случаях.

* Если пользователь вручную обновляет страницу.
* Если веб-сервер становится недоступным и пользователь вынужден перезагрузить страницу, чтобы подключиться к другому серверу.

Сведения об определении шаблонов URL-адресов с помощью директивы `@page` см. в разделе <xref:blazor/fundamentals/routing>.

### <a name="client-side-in-the-browser"></a>На стороне клиента в браузере

Для временных данных, создаваемых пользователем, общим резервным хранилищем являются коллекции браузера `localStorage` и `sessionStorage`. Приложению не требуется управлять сохраненным состоянием или очищать его, если канал прерван, что является преимуществом по сравнению с хранилищем на стороне сервера.

> [!NOTE]
> "На стороне клиента" в этом разделе относится к сценариям на стороне клиента в браузере, а не к [модели размещения Blazor WebAssembly](xref:blazor/hosting-models#blazor-webassembly). `localStorage` и `sessionStorage` можно использовать в приложениях Blazor WebAssembly, но только путем написания пользовательского кода или использования стороннего пакета.

`localStorage` и `sessionStorage` различаются следующим образом.

* `localStorage` входит в область браузера пользователя. Если пользователь перезагружает страницу или закрывает и снова открывает браузер, состояние сохраняется. Если пользователь открывает несколько вкладок браузера, это состояние совместно используется на нескольких вкладках. Данные сохраняются в `localStorage` до тех пор, пока они не будут явно очищены.
* `sessionStorage` входит в область вкладки браузера пользователя. Если пользователь перезагружает вкладку, состояние сохраняется. Если пользователь закрывает вкладку или браузер, состояние теряется. Если пользователь открывает несколько вкладок браузера, каждая вкладка имеет собственную независимую версию данных.

Как правило, `sessionStorage` более безопасно для использования. `sessionStorage` позволяет избежать риска, когда пользователь открывает несколько вкладок и сталкивается со следующими проблемами.

* Ошибки в хранилище состояний на разных вкладках.
* Путаница в работе, когда одна вкладка перезаписывает состояние других.

`localStorage` является лучшим выбором, если приложение должно сохранять состояние в случае закрытия и повторного открытия браузера.

Предостережения при использовании хранилища браузера.

* Аналогично использованию базы данных на стороне сервера, загрузка и сохранение данных выполняются асинхронно.
* В отличие от базы данных на стороне сервера, хранилище недоступно во время предварительной отрисовки, так как запрошенная страница не существует в браузере во время выполнения этой стадии.
* Для приложений Blazor Server имеет смысл хранить данные в пределах нескольких килобайт. При превышении этого порога необходимо учитывать последствия производительности, поскольку данные загружаются и сохраняются по сети.
* Пользователи могут просматривать и изменять данные. [Защита данных](xref:security/data-protection/introduction) ASP.NET Core может снизить этот риск.

## <a name="third-party-browser-storage-solutions"></a>Сторонние решения для хранения в браузере

Сторонние пакеты NuGet предоставляют интерфейсы API для работы с `localStorage` и `sessionStorage`.

Стоит рассмотреть выбор пакета, который прозрачно использует [защиту данных](xref:security/data-protection/introduction) ASP.NET Core. Защита данных ASP.NET Core шифрует хранимые данные и уменьшает потенциальный риск несанкционированного изменения хранимых данных. Если сериализованные данные JSON хранятся в виде обычного текста, пользователи могут просматривать данные с помощью средств разработчика браузера, а также изменять сохраненные данные. Защита данных не всегда является проблемой, так как данные могут быть тривиальными по своей природе. Например, чтение или изменение сохраненного цвета элемента пользовательского интерфейса не является серьезной угрозой безопасности для пользователя или организации. Не разрешайте пользователям проверять или изменять *конфиденциальные данные*.

## <a name="protected-browser-storage-experimental-package"></a>Экспериментальный пакет Protected Browser Storage

Примером пакета NuGet, который предоставляет [защиту данных](xref:security/data-protection/introduction) для `localStorage` и `sessionStorage`, является [`Microsoft.AspNetCore.ProtectedBrowserStorage`](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).

> [!WARNING]
> `Microsoft.AspNetCore.ProtectedBrowserStorage` является неподдерживаемым экспериментальным пакетом, который в настоящее время не подходит для использования в рабочей среде.

### <a name="installation"></a>Установка

Чтобы установить пакет `Microsoft.AspNetCore.ProtectedBrowserStorage`, выполните следующие действия.

1. В проекте приложения Blazor Server добавьте ссылку на пакет [`Microsoft.AspNetCore.ProtectedBrowserStorage`](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).
1. В HTML верхнего уровня (например, в файле `Pages/_Host.cshtml` в шаблоне проекта по умолчанию) добавьте следующий тег `<script>`:

   ```html
   <script src="_content/Microsoft.AspNetCore.ProtectedBrowserStorage/protectedBrowserStorage.js"></script>
   ```

1. В методе `Startup.ConfigureServices` вызовите `AddProtectedBrowserStorage`, чтобы добавить службы `localStorage` и `sessionStorage` в коллекцию служб.

   ```csharp
   services.AddProtectedBrowserStorage();
   ```

### <a name="save-and-load-data-within-a-component"></a>Сохранение и загрузка данных в компоненте

В любом компоненте, требующем загрузки или сохранения данных в хранилище браузера, используйте [`@inject`](xref:mvc/views/razor#inject) для вставки экземпляра одного из следующих компонентов.

* `ProtectedLocalStorage`
* `ProtectedSessionStorage`

Выбор зависит от того, какое резервное хранилище вы хотите использовать. В следующем примере используется `sessionStorage`.

```razor
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedSessionStorage ProtectedSessionStore
```

Инструкцию `@using` можно поместить в файл `_Imports.razor`, а не в компонент. Использование файла `_Imports.razor` делает пространство имен доступным для больших сегментов приложения или всего приложения.

Чтобы сохранить значение `currentCount` в компонент шаблона проекта `Counter`, измените метод `IncrementCount` для использования `ProtectedSessionStore.SetAsync`.

```csharp
private async Task IncrementCount()
{
    currentCount++;
    await ProtectedSessionStore.SetAsync("count", currentCount);
}
```

В больших и более реалистичных приложениях хранение отдельных полей является маловероятной ситуацией. Приложения, скорее всего, будут хранить все объекты модели, включающие сложное состояние. `ProtectedSessionStore` автоматически сериализует и десериализует данные JSON.

В предыдущем примере кода данные `currentCount` хранятся в виде `sessionStorage['count']` в браузере пользователя. Данные не хранятся в виде обычного текста, а защищаются с помощью [защиты данных](xref:security/data-protection/introduction) ASP.NET Core. Зашифрованные данные можно увидеть, если `sessionStorage['count']` оценивается в консоли разработчика браузера.

Чтобы восстановить данные `currentCount`, когда пользователь снова возвращается в компонент `Counter` (в том числе если он находится в совершенно новом канале), используйте `ProtectedSessionStore.GetAsync`.

```csharp
protected override async Task OnInitializedAsync()
{
    currentCount = await ProtectedSessionStore.GetAsync<int>("count");
}
```

Если параметры компонента включают состояние навигации, вызовите `ProtectedSessionStore.GetAsync` и назначьте результат в <xref:Microsoft.AspNetCore.Components.ComponentBase.OnParametersSetAsync%2A>, а не в <xref:Microsoft.AspNetCore.Components.ComponentBase.OnInitializedAsync%2A>. <xref:Microsoft.AspNetCore.Components.ComponentBase.OnInitializedAsync%2A> вызывается только один раз при первом создании экземпляра компонента. <xref:Microsoft.AspNetCore.Components.ComponentBase.OnInitializedAsync%2A> не вызывается позже, если пользователь переходит на другой URL-адрес, оставаясь на той же странице. Дополнительные сведения см. в разделе <xref:blazor/components/lifecycle>.

> [!WARNING]
> Примеры в этом разделе работают только в том случае, если на сервере не включена предварительная отрисовка. При включенной предварительной отрисовке возникает ошибка следующего вида.
>
> > В настоящее время вызовы взаимодействия JavaScript не могут быть выполнены. Это связано с тем, что компонент предварительно отрисовывается.
>
> Отключите предварительную отрисовку или добавьте дополнительный код для работы с предварительной отрисовкой. Дополнительные сведения о написании кода, который работает с предварительной отрисовкой, см. в разделе [Обработка предварительной отрисовки](#handle-prerendering).

### <a name="handle-the-loading-state"></a>Обработка состояния загрузки

Так как хранилище браузера является асинхронным (доступным через сетевое подключение), всегда есть период времени, прежде чем данные будут загружены и доступны для использования компонентом. Для достижения лучших результатов перед отображением пустых данных или данных по умолчанию выводится сообщение о состоянии загрузки.

Один из подходов состоит в том, чтобы определить, является ли значение данных равным `null` (все еще загружаются) или нет. В компоненте `Counter` по умолчанию количество хранится в `int`. Сделайте `currentCount` допускающим значение NULL, добавив вопросительный знак (`?`) к типу (`int`).

```csharp
private int? currentCount;
```

Вместо безусловного отображения количества и кнопки **`Increment`** настройте отображение этих элементов только в том случае, если данные загружены.

```razor
@if (currentCount.HasValue)
{
    <p>Current count: <strong>@currentCount</strong></p>

    <button @onclick="IncrementCount">Increment</button>
}
else
{
    <p>Loading...</p>
}
```

### <a name="handle-prerendering"></a>Обработка предварительной отрисовки

Во время предварительной отрисовки происходит следующее:

* интерактивное подключение к браузеру пользователя не существует;
* в браузере еще нет страницы, на которой можно запустить код JavaScript.

`localStorage` или `sessionStorage` недоступны во время предварительной отрисовки. Если компонент пытается взаимодействовать с хранилищем, возникает ошибка следующего вида.

> В настоящее время вызовы взаимодействия JavaScript не могут быть выполнены. Это связано с тем, что компонент предварительно отрисовывается.

Одним из способов устранения этой ошибки является отключение предварительной отрисовки. Обычно это наилучший вариант, если приложение активно использует хранилище в браузере. Предварительная отрисовка увеличивает сложность и не дает приложению никаких преимуществ, так как приложение не может выдать какое-либо полезное содержимое, пока не станут доступны `localStorage` или `sessionStorage`.

Чтобы отключить предварительную отрисовку, откройте файл `Pages/_Host.cshtml` и измените `render-mode` [вспомогательной функции тега компонента](xref:mvc/views/tag-helpers/builtin-th/component-tag-helper) на <xref:Microsoft.AspNetCore.Mvc.Rendering.RenderMode.Server>.

Предварительная отрисовка может быть полезной для других страниц, которые не используют `localStorage` или `sessionStorage`. Чтобы включить предварительную отрисовку, отложите операцию загрузки до тех пор, пока браузер не подключится к каналу. Ниже приведен пример хранения значения счетчика.

```razor
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedLocalStorage ProtectedLocalStore

... rendering code goes here ...

@code {
    private int? currentCount;
    private bool isConnected = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // When execution reaches this point, the first *interactive* render
            // is complete. The component has an active connection to the browser.
            isConnected = true;
            await LoadStateAsync();
            StateHasChanged();
        }
    }

    private async Task LoadStateAsync()
    {
        currentCount = await ProtectedLocalStore.GetAsync<int>("prerenderedCount");
    }

    private async Task IncrementCount()
    {
        currentCount++;
        await ProtectedSessionStore.SetAsync("count", currentCount);
    }
}
```

### <a name="factor-out-the-state-preservation-to-a-common-location"></a>Перенос сохранения состояния в общее расположение

Если многие компоненты используют хранилище на основе браузера, повторная реализация кода поставщика состояний много раз создает дублирование кода. Одним из вариантов предотвращения дублирования кода является создание *родительского компонента поставщика состояний*, который инкапсулирует логику поставщика состояний. Дочерние компоненты могут работать с сохраненными данными без учета механизма сохранения состояния.

В следующем примере компонента `CounterStateProvider` данные счетчика сохраняются.

```razor
@using Microsoft.AspNetCore.ProtectedBrowserStorage
@inject ProtectedSessionStorage ProtectedSessionStore

@if (hasLoaded)
{
    <CascadingValue Value="@this">
        @ChildContent
    </CascadingValue>
}
else
{
    <p>Loading...</p>
}

@code {
    private bool hasLoaded;

    [Parameter]
    public RenderFragment ChildContent { get; set; }

    public int CurrentCount { get; set; }

    protected override async Task OnInitializedAsync()
    {
        CurrentCount = await ProtectedSessionStore.GetAsync<int>("count");
        hasLoaded = true;
    }

    public async Task SaveChangesAsync()
    {
        await ProtectedSessionStore.SetAsync("count", CurrentCount);
    }
}
```

Компонент `CounterStateProvider` обрабатывает этап загрузки, не выполняя отрисовку его дочернего содержимого до завершения загрузки.

Чтобы использовать компонент `CounterStateProvider`, оберните экземпляр компонента вокруг любого другого компонента, которому требуется доступ к состоянию счетчика. Чтобы сделать состояние доступным для всех компонентов в приложении, оберните `CounterStateProvider` компонент вокруг <xref:Microsoft.AspNetCore.Components.Routing.Router> в компоненте `App` (`App.razor`).

```razor
<CounterStateProvider>
    <Router AppAssembly="typeof(Startup).Assembly">
        ...
    </Router>
</CounterStateProvider>
```

Упакованные компоненты получают и могут изменять состояние сохраненного счетчика. Следующий компонент `Counter` реализует этот шаблон.

```razor
@page "/counter"

<p>Current count: <strong>@CounterStateProvider.CurrentCount</strong></p>

<button @onclick="IncrementCount">Increment</button>

@code {
    [CascadingParameter]
    private CounterStateProvider CounterStateProvider { get; set; }

    private async Task IncrementCount()
    {
        CounterStateProvider.CurrentCount++;
        await CounterStateProvider.SaveChangesAsync();
    }
}
```

Предыдущий компонент не требуется для взаимодействия с `ProtectedBrowserStorage` и не имеет отношения к этапу "загрузки".

Для работы с предварительной отрисовкой, как описано выше, `CounterStateProvider` можно сделать так, чтобы все компоненты, использующие данные счетчика, автоматически работали с предварительной отрисовкой. Дополнительные сведения см. в разделе [Обработка предварительной отрисовки](#handle-prerendering).

В целом рекомендуется использовать шаблон *родительского компонента поставщика состояний* в следующих случаях.

* Для использования состояния во многих других компонентах.
* Если имеется только один объект состояния верхнего уровня для сохранения.

Чтобы сохранить множество различных объектов состояния и использовать разные подмножества объектов в разных местах, лучше избегать глобальной обработки загрузки и сохранения состояния.
